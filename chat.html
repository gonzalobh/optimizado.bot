<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Chat del Hotel</title>

  <!-- Firebase (compat) -->
  <script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-storage-compat.js"></script>

  <!-- UI libs -->
  <script src="https://cdn.tailwindcss.com"></script>
<script src="https://unpkg.com/lucide@0.292.0/dist/umd/lucide.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700&display=swap" rel="stylesheet">

  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: { sans: ['Manrope','system-ui','-apple-system','Segoe UI','Roboto','sans-serif'] },
          boxShadow: { soft: '0 6px 22px rgba(0,0,0,.08)' }
        }
      }
    }
  </script>

  <style>
:root {
  --chat-primary:#111111;
  --assistant-text:#000000; /* üÜï color del texto del asistente */
  --chat-client-text:#ffffff;
  --chat-header-text:#1f2937;
  --avatar-radius:50%;
}
    html,body { height:100%; background:#ececec; }
    body { font-family: Manrope, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; -webkit-tap-highlight-color: transparent; }
    /* Contenedor principal del chat (ocupando todo el iframe/p√°gina) */
    #chatWindow {
      position: fixed; inset: 0; background:#ececec;
      display:flex; flex-direction:column; z-index: 9999;
      height: 100dvh; opacity:1; transform:none;
    }
    /* Header fijo */
    #chatHeader { position: sticky; top:0; z-index:10; }
    /* Scroll mensajes */
    #chatBox { flex:1; overflow-y:auto; -webkit-overflow-scrolling:touch; padding:12px 16px 16px; }
    /* Footer input fijo */
    #chatFooter { position: sticky; bottom:0; z-index:10;padding:12px 16px calc(12px + env(safe-area-inset-bottom)); }
    /* Burbujas */
    .chat-bubble { max-width: 86%; font-size:15px; line-height:1.45; }
    .chat-assistant { display:flex; align-items:flex-start; gap:10px; background:transparent; }
.chat-assistant .msg {
  background:#fff;
  border-radius:14px;
  padding:10px 14px;
  box-shadow:0 1px 3px rgba(0,0,0,.08);
  color: var(--assistant-text);
}
    .chat-user { margin-left:auto; color:var(--chat-client-text, #fff); background:var(--chat-primary); border-radius:14px; padding:10px 14px; }
    /* Enlaces dentro de mensajes */
    .chat-bubble a:not(.pill-btn) { color:#0a66ff; text-decoration:underline; }
    .chat-bubble a:not(.pill-btn):hover { text-decoration:none; }
    /* Bot√≥n enviar */
    #sendChatBtn { flex-shrink:0; width:40px; height:40px; border-radius:9999px; display:flex; align-items:center; justify-content:center; background:#000; color:#fff; }
    /* Color din√°mico aplicado tambi√©n al nombre del hotel */
    #chatHeader { color: var(--chat-header-text, #1f2937); }
    #chatHotelName { color: var(--chat-header-text, var(--chat-primary)) !important; }
    #chatMenuBtn,
    #chatHeader button { color: var(--chat-header-text, #1f2937) !important; }
    #chatHeader button svg,
    #chatHeader svg { color: inherit !important; stroke: currentColor !important; }
    /* Avatar asistente dentro de mensaje */
    .avatar-icon { width:36px; height:36px; border-radius:var(--avatar-radius, 50%); object-fit:cover; margin-top:2px; flex-shrink:0; box-shadow:0 1px 3px rgba(0,0,0,.1); }
    /* Cards (autoResponses tipo cards) */
    .cards { display:flex; gap:12px; overflow-x:auto; padding:2px; }
    .card {
      flex:0 0 260px; background:#fff; border-radius:14px; box-shadow:0 1px 3px rgba(0,0,0,.08);
      border:1px solid #eaeaea; overflow:hidden;
    }
    .card img { width:100%; height:140px; object-fit:cover; display:block; }
    .card .in { padding:10px 12px; }
    .card .title { font-weight:700; font-size:15px; }
    .card .sub { font-size:13px; color:#555; margin-top:2px; }
    .pill-btn {
      display:inline-block; margin-top:8px; border:1.5px solid var(--chat-primary);
      color:var(--chat-primary); border-radius:9999px; padding:6px 10px; font-size:12px;
    }
    .pill-btn:hover { background:var(--chat-primary); color:#fff; }
    .chat-bubble .pill-btn {
      color:inherit;
      border-color:currentColor;
      text-decoration:none;
    }
    .chat-bubble .pill-btn:hover {
      background:var(--chat-primary);
      border-color:var(--chat-primary);
      color:#fff;
      text-decoration:none;
    }
    /* Input */
    #chatInput {
      flex:1; background:#fff; border:1px solid #ddd; border-radius:10px; padding:10px 14px; font-size:16px;
      outline:none; box-shadow:0 0 4px 1px #02243114; transition: box-shadow .2s;
    }
    #chatInput:focus { box-shadow:0 0 6px 1px #02243126; }

    .dot {
  width: 6px;
  height: 6px;
  background-color: #888; /* puedes cambiar el color */
  border-radius: 50%;
  display: inline-block;
  animation: blink 1.2s infinite;
}

.dot:nth-child(2) { animation-delay: 0.2s; }
.dot:nth-child(3) { animation-delay: 0.4s; }

@keyframes blink {
  0%, 80%, 100% { opacity: 0.3; }
  40% { opacity: 1; }
}

  </style>
</head>
<body>
  <!-- VISTA DEL CHAT (siempre visible, sin hero ni men√∫s) -->
  <div id="chatWindow">
    <!-- Header -->
    <div id="chatHeader" class="bg-white flex items-center justify-between px-4 py-4">
      <div class="flex items-center gap-3">
        <img id="chatLogo" class="w-9 h-9 rounded-full shadow hidden" alt="Logo">
        <span id="chatHotelName" class="font-semibold text-[17px] text-gray-800">Tomos Bot</span>
      </div>
      <div class="flex items-center gap-4">
        <div class="relative">
          <button id="chatMenuBtn" type="button" class="text-gray-500 select-none cursor-pointer flex items-center justify-center w-8 h-8 rounded-full hover:bg-gray-100" title="Men√∫" aria-haspopup="true" aria-expanded="false">‚Ä¢‚Ä¢‚Ä¢</button>
          <div id="chatMenu" class="hidden absolute right-0 mt-2 w-56 bg-white rounded-lg shadow-lg border border-gray-100 py-1 text-sm z-20">
            <button id="downloadChatBtn" type="button" class="w-full px-3 py-2 text-left text-gray-700 hover:bg-gray-100 flex items-center gap-2">
              <i data-lucide="download" class="w-4 h-4"></i>
              <span>Download conversation</span>
            </button>
          </div>
        </div>
        <button id="closeChat" class="text-gray-400 hover:text-gray-600" title="Cerrar">
          <i data-lucide="x" class="w-5 h-5"></i>
        </button>
      </div>
    </div>

    <!-- Mensajes -->
    <div id="chatBox" class="flex flex-col gap-3"></div>

    <!-- Footer -->
    <div id="chatFooter" class="flex items-center gap-3">
      <input id="chatInput" type="text" placeholder="√âcrivez votre message‚Ä¶" />
      <button id="sendChatBtn"><i data-lucide="arrow-up" class="w-5 h-5"></i></button>
    </div>

<div class="flex justify-center items-center py-2">
  <a href="https://tomos.io" target="_blank" rel="noopener noreferrer" 
     class="flex items-center gap-2 text-gray-500 text-xs">
    <span>Powered by Tomos</span>
  </a>
</div>


  </div>

  <script>
    let USER_LANGUAGE = 'en';
    document.addEventListener('DOMContentLoaded', () => {
      const BROWSER_LANGUAGE = (navigator.language || navigator.userLanguage || 'en').slice(0, 2).toLowerCase();
      const TEXT_TRANSLATIONS = {
        es: {
          inputPlaceholder: 'Escribe tu mensaje‚Ä¶',
          downloadConversation: 'Descargar conversaci√≥n'
        },
        en: {
          inputPlaceholder: 'Write your message‚Ä¶',
          downloadConversation: 'Download conversation'
        },
        fr: {
          inputPlaceholder: '√âcrivez votre message‚Ä¶',
          downloadConversation: 'T√©l√©charger la conversation'
        }
      };

      const selected = TEXT_TRANSLATIONS[BROWSER_LANGUAGE] || TEXT_TRANSLATIONS.en;

      const chatInput = document.getElementById('chatInput');
      if (chatInput) {
        chatInput.placeholder = selected.inputPlaceholder;
      }

      USER_LANGUAGE = BROWSER_LANGUAGE;

      const downloadChatBtnLabel = document.querySelector('#downloadChatBtn span');
      if (downloadChatBtnLabel) {
        downloadChatBtnLabel.textContent = selected.downloadConversation;
      }
    });
  </script>

  <script>
/* =========================
   FIREBASE CONFIG
========================= */
const FIREBASE_CONFIG = {
  apiKey: "AIzaSyC2c3S_NtouIjHPrk5LM5c0DQoTWyBrzH4",
  authDomain: "timbre-c9547.firebaseapp.com",
  databaseURL: "https://timbre-c9547-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "timbre-c9547",
  storageBucket: "timbre-c9547.firebasestorage.app",
  messagingSenderId: "127064655657",
  appId: "1:127064655657:web:a4e99dcbc6ab33f32c1938"
};

let app;
let db;

try {
  app = firebase.app(); // reuse existing app if already initialized
} catch (e) {
  app = firebase.initializeApp(FIREBASE_CONFIG);
}
db = firebase.database(app);

function dbRef(path) {
  return db.ref(path);
}

function getEmpresa(){
  const url = new URL(window.location.href);
  const p = (url.searchParams.get('empresa') || localStorage.getItem('empresa') || 'Boletum').trim();
  localStorage.setItem('empresa', p);
  return p;
}
let EMPRESA = getEmpresa();

function getBot() {
  const url = new URL(window.location.href);
  const storageKey = `bot:${EMPRESA}`;
  const raw = (url.searchParams.get('bot') || localStorage.getItem(storageKey) || 'default').trim();
  const bot = raw || 'default';
  localStorage.setItem(storageKey, bot);
  return bot;
}
let BOT = getBot();

const CHAT_SESSION_KEY = `chatId:${EMPRESA}:${BOT}`;
let CHAT_ID = sessionStorage.getItem(CHAT_SESSION_KEY) || `${Date.now()}`;
sessionStorage.setItem(CHAT_SESSION_KEY, CHAT_ID);

const chatLogBaseRef = dbRef(`empresas/${EMPRESA}/bots/${BOT}/conversaciones/${CHAT_ID}`);
const chatMessagesRef = chatLogBaseRef.child('messages');
const chatMetaRef = chatLogBaseRef.child('meta');
let chatMetaCache = null;
let chatStartedAt = null;
const conversationLog = []; // {sender:'bot'|'user', text:string, time:number}
const pendingMessagesQueue = [];
let hasUserSentMessage = false;

async function fetchUserLocation() {
  try {
    const response = await fetch('https://ipapi.co/json/');
    if (!response.ok) throw new Error('Failed to fetch location');
    const data = await response.json();
    return {
      ip: data?.ip || '',
      country: data?.country_name || '',
      city: data?.city || '',
      region: data?.region || data?.region_name || '',
      countryCode: data?.country || ''
    };
  } catch (err) {
    console.warn('No se pudo obtener la ubicaci√≥n del usuario', err);
    return null;
  }
}

function flagFromCountryCode(code = '') {
  const clean = code.trim().toUpperCase();
  if (clean.length !== 2) return '';
  const BASE = 0x1F1E6 - 'A'.charCodeAt(0);
  return String.fromCodePoint(
    ...clean.split('').map((char) => char.charCodeAt(0) + BASE)
  );
}

async function saveUserLocationToFirebase() {
  if (!chatMetaRef) return;
  try {
    const location = await fetchUserLocation();
    if (!location) return;
    const payload = {
      ...location,
      flag: flagFromCountryCode(location.countryCode)
    };
    await chatMetaRef.child('location').set(payload);
  } catch (err) {
    console.warn('No se pudo guardar la ubicaci√≥n del usuario', err);
  }
}

let leadPromptShown = false;
let leadCaptureState = null;
let leadCaptureCompleted = false;
let leadCaptureEnabled = true;
let skipNextUserMessageForLeadCapture = false;

let SYSTEM_PROMPT = "";
let systemPromptRef = null;

chatMetaRef.once('value').then(snapshot => {
  chatMetaCache = snapshot.val() || {};
  if (chatMetaCache.startedAt) {
    chatStartedAt = chatMetaCache.startedAt;
  }
}).catch(err => console.warn('No se pudo cargar la metadata del chat', err));

function getChatUserName() {
  const candidates = [
    `chatUserName:${EMPRESA}:${BOT}`,
    'chatUserName',
    'userName',
    'guestName',
    'name'
  ];
  for (const key of candidates) {
    const fromSession = sessionStorage.getItem(key);
    if (fromSession && fromSession.trim()) return fromSession.trim();
    const fromLocal = localStorage.getItem(key);
    if (fromLocal && fromLocal.trim()) return fromLocal.trim();
  }
  return 'Guest';
}

function stripHtml(html) {
  const tmp = document.createElement('div');
  tmp.innerHTML = html || '';
  return tmp.textContent || tmp.innerText || '';
}

function updateChatMeta(lastMessage, timestamp) {
  if (!chatMetaRef) return;
  const updates = {
    userName: getChatUserName(),
    lastMessage: lastMessage || '',
    lastUpdated: timestamp
  };
  if (!chatStartedAt) {
    chatStartedAt = chatMetaCache?.startedAt || timestamp;
  }
  if (!chatMetaCache?.startedAt) {
    updates.startedAt = chatStartedAt;
  }
  chatMetaRef.update(updates).then(() => {
    chatMetaCache = { ...(chatMetaCache || {}), ...updates };
  }).catch(err => console.warn('No se pudo actualizar la metadata del chat', err));
}

function persistChatPayload(payload) {
  if (!chatMessagesRef || !payload) return;
  try {
    const newRef = chatMessagesRef.push();
    newRef.set(payload).catch(err => console.warn('No se pudo guardar el mensaje del chat', err));
  } catch (err) {
    console.warn('No se pudo registrar la referencia del mensaje', err);
  }
  updateChatMeta(payload.text, payload.time);
}

function flushPendingMessages() {
  if (!pendingMessagesQueue.length) return;
  while (pendingMessagesQueue.length) {
    const pending = pendingMessagesQueue.shift();
    persistChatPayload(pending);
  }
}

function logChatMessage(sender, text) {
  if (!chatMessagesRef || !sender) return;
  const now = Date.now();
  const safeText = text == null ? '' : String(text);
  const payload = {
    sender,
    text: safeText,
    time: now
  };
  conversationLog.push({ sender, text: safeText, time: now });
  const isUserMessage = sender === 'user' && safeText.trim().length > 0;
  if (!hasUserSentMessage) {
    if (isUserMessage) {
      hasUserSentMessage = true;
      saveUserLocationToFirebase();
      flushPendingMessages();
      persistChatPayload(payload);
    } else {
      pendingMessagesQueue.push(payload);
    }
    return;
  }
  persistChatPayload(payload);
}

function initSystemPromptListener() {
  if (systemPromptRef) {
    try {
      systemPromptRef.off();
    } catch (err) {
      console.warn('No se pudo desuscribir del prompt anterior', err);
    }
    systemPromptRef = null;
  }

  if (!EMPRESA || !BOT) {
    SYSTEM_PROMPT = "";
    return;
  }

  systemPromptRef = db.ref(`empresas/${EMPRESA}/bots/${BOT}/config/prompt`);
  systemPromptRef.on('value', (snap) => {
    const value = snap.val();
    SYSTEM_PROMPT = typeof value === 'string' ? value : '';
  }, (err) => {
    console.warn('No se pudo cargar el prompt del sistema', err);
    SYSTEM_PROMPT = '';
  });
}

let useLegacyBotPath = false;
let botCollectionPath = null;

function getDefaultBotCollectionPath() {
  return `empresas/${EMPRESA}/bots`;
}

function getConfigBotCollectionPath() {
  return `empresas/${EMPRESA}/config/bots`;
}

function getLegacyBotCollectionPath() {
  return `${EMPRESA}/bots`;
}

function getBotBasePath() {
  if (botCollectionPath) {
    const basePath = botCollectionPath.startsWith('empresas/')
      ? botCollectionPath
      : `empresas/${botCollectionPath}`;
    return `${basePath}/${BOT}`;
  }
  return useLegacyBotPath ? `empresas/${EMPRESA}` : `empresas/${EMPRESA}/bots/${BOT}`;
}

function eref(path){ return db.ref(`${getBotBasePath()}/${path}`); }

function applyLeadCaptureConfig(value) {
  const normalized = value === false ? false : true;
  leadCaptureEnabled = normalized;
  if (!normalized) {
    leadPromptShown = false;
    leadCaptureState = null;
    leadCaptureCompleted = false;
    skipNextUserMessageForLeadCapture = false;
  }
}

try {
  eref('config/leadCaptureEnabled').on('value', (snap) => {
    applyLeadCaptureConfig(snap.val());
  }, (err) => {
    console.warn('No se pudo leer config/leadCaptureEnabled', err);
  });
} catch (err) {
  console.warn('No se pudo inicializar el listener de lead capture', err);
}

async function prepareBotPath() {
  const candidates = [
    getDefaultBotCollectionPath(),
    getConfigBotCollectionPath(),
    getLegacyBotCollectionPath()
  ];

  for (const path of candidates) {
    try {
      await db.ref(`${path}/${BOT}`).once('value');
      botCollectionPath = path;
      useLegacyBotPath = false;
      return;
    } catch (err) {
      if (err?.code === 'PERMISSION_DENIED') {
        continue;
      }
      console.warn('No se pudo verificar la ruta del bot', path, err);
    }
  }

  try {
    const legacySnap = await db.ref(`empresas/${EMPRESA}`).once('value');
    if (legacySnap.exists()) {
      botCollectionPath = null;
      useLegacyBotPath = true;
      return;
    }
  } catch (err) {
    console.warn('No se pudo verificar la ruta legacy del bot', err);
  }

  botCollectionPath = getConfigBotCollectionPath();
  useLegacyBotPath = false;
}

/* =========================
   IA PROXY
   - Cambia PROXY_URL a tu endpoint (Vercel, etc.)
   - Tambi√©n puedes pasar ?proxy=https://tu-endpoint
========================= */
const urlParams = new URLSearchParams(location.search);
let PROXY_URL = urlParams.get('proxy') || "https://hotel-chat-proxy.vercel.app/api/chat";
// Espera respuesta JSON: { choices: [ { message: { content: "‚Ä¶" } } ] } (OpenAI-style)

/* =========================
   UI ELEMENTS
========================= */
const chatBox = document.getElementById('chatBox');
const input   = document.getElementById('chatInput');
const sendBtn = document.getElementById('sendChatBtn');
const hotelNameEl = document.getElementById('chatHotelName');
const chatLogo = document.getElementById('chatLogo');
const chatAvatarHead = document.getElementById('chatAvatarHead');
const chatMenuBtn = document.getElementById('chatMenuBtn');
const chatMenu = document.getElementById('chatMenu');
const downloadChatBtn = document.getElementById('downloadChatBtn');

function linkify(text){
  if (!text) return "";
  const urlRegex=/((https?:\/\/|www\.)[^\s]+|[a-zA-Z0-9-]+\.[a-z]{2,}(\/\S*)?)/gi;
  return text.replace(urlRegex, m=>{
    let u=m; if(!/^https?:\/\//i.test(u)) u="https://"+u;
    return `<a href="${u}" target="_blank" rel="noopener noreferrer">${m}</a>`;
  });
}

/* =========================
   RENDER MENSAJES
========================= */
function createAssistantBubble(avatarUrl) {
  const wrap = document.createElement('div');
  wrap.className = 'chat-bubble chat-assistant';
  const avatar = document.createElement('img');
  avatar.className = 'avatar-icon';
  if (avatarUrl) {
    avatar.src = avatarUrl;
  } else {
    avatar.style.display = 'none';
  }
  const msg = document.createElement('div');
  msg.className = 'msg';
  const assistantColor = getComputedStyle(document.documentElement)
    .getPropertyValue('--assistant-text') || '#000000';
  msg.style.color = assistantColor;
  wrap.appendChild(avatar);
  wrap.appendChild(msg);
  chatBox.appendChild(wrap);
  chatBox.scrollTop = chatBox.scrollHeight;
  return { wrap, msg };
}

function addAssistantMessageHTML(html, {avatarUrl, rawText}={}){
  const { msg } = createAssistantBubble(avatarUrl);
  msg.innerHTML = html;
  const plain = rawText != null ? rawText : stripHtml(html);
  logChatMessage('bot', plain);
}

function addAssistantMessage(text, opts={}){
  const { avatarUrl, animate = true } = opts;
  const content = text || "";
  if (!animate) {
    const md = marked.parse(content);
    addAssistantMessageHTML(md, { avatarUrl, rawText: content });
    return;
  }

  const { msg } = createAssistantBubble(avatarUrl);
  if (!content) {
    logChatMessage('bot', '');
    return;
  }

  let index = 0;
  const total = content.length;
  const baseDelay = 18;
  const minChunk = 1;
  const chunkSize = Math.max(minChunk, Math.ceil(total / 120));

  function typeNextChunk() {
    index = Math.min(total, index + chunkSize);
    const partial = content.slice(0, index);
    msg.innerHTML = marked.parse(partial);
    chatBox.scrollTop = chatBox.scrollHeight;
    if (index < total) {
      setTimeout(typeNextChunk, baseDelay);
    } else {
      logChatMessage('bot', content);
    }
  }

  typeNextChunk();
}
function addUserMessage(text){
  const bubble = document.createElement('div');
  bubble.className = 'chat-bubble chat-user';
  bubble.textContent = text;
  chatBox.appendChild(bubble);
  chatBox.scrollTop = chatBox.scrollHeight;
  logChatMessage('user', text);
}
function addTyping(){
  const el = document.createElement('div');
  el.className = 'chat-bubble chat-assistant';
  el.dataset.typing = '1';
  el.innerHTML = `
    <img class="avatar-icon" id="__typAva" />
    <div class="msg flex items-center gap-1">
      <span class="dot"></span>
      <span class="dot"></span>
      <span class="dot"></span>
    </div>
  `;
  chatBox.appendChild(el);
  chatBox.scrollTop = chatBox.scrollHeight;
  return el;
}

function removeTyping(el){ if(el && el.parentNode) el.parentNode.removeChild(el); }

function showTypingIndicator({ avatarUrl } = {}) {
  const typing = addTyping();
  const avatarImg = typing.querySelector('#__typAva');
  const avatar = avatarUrl || CURRENT.avatarUrl;
  if (avatarImg) {
    if (avatar) {
      avatarImg.src = avatar;
    } else {
      avatarImg.style.display = 'none';
    }
  }
  return typing;
}

function delayedAssistantAction(action, delayMs = 1800, opts = {}) {
  const typing = showTypingIndicator(opts);
  setTimeout(() => {
    removeTyping(typing);
    action();
  }, delayMs);
}

function renderAssistantMessage(text) {
  addAssistantMessage(text, { avatarUrl: CURRENT.avatarUrl });
}

function translate(lang, dict) {
  return dict[lang] || dict['en'] || Object.values(dict)[0];
}

async function startSequentialLeadCapture() {
  leadCaptureState = { step: 1, name: null, email: null, phone: null };
  askName();
}

function askName() {
  renderAssistantMessage(translate(USER_LANGUAGE, {
    es: "¬øCu√°l es tu nombre?",
    en: "What's your name?",
    fr: "Quel est votre nom ?",
    de: "Wie ist dein Name?",
    pl: "Jak masz na imiƒô?",
    pt: "Qual √© o seu nome?"
  }));
}

function askEmail() {
  renderAssistantMessage(translate(USER_LANGUAGE, {
    es: "¬øCu√°l es tu email? (opcional)",
    en: "What's your email? (optional)",
    fr: "Quel est votre email ? (optionnel)",
    de: "Wie lautet deine E-Mail? (optional)",
    pl: "Jaki jest tw√≥j email? (opcjonalnie)",
    pt: "Qual √© o seu email? (opcional)"
  }));
}

function askPhone() {
  renderAssistantMessage(translate(USER_LANGUAGE, {
    es: "¬øCu√°l es tu tel√©fono? (opcional)",
    en: "What's your phone number? (optional)",
    fr: "Quel est votre num√©ro de t√©l√©phone ? (optionnel)",
    de: "Wie lautet deine Telefonnummer? (optional)",
    pl: "Jaki jest tw√≥j numer telefonu? (opcjonalnie)",
    pt: "Qual √© o seu telefone? (opcional)"
  }));
}

function buildLeadSummaryTranscript(maxEntries = 16) {
  if (!conversationLog.length) return '';
  const relevantEntries = conversationLog.slice(-Math.max(1, maxEntries));
  return relevantEntries
    .map(entry => {
      const prefix = entry.sender === 'bot' ? 'Asistente' : 'Usuario';
      const cleaned = (entry.text || '')
        .replace(/\s+/g, ' ')
        .trim();
      return `${prefix}: ${cleaned}`.trim();
    })
    .filter(Boolean)
    .join('\n');
}

function parseLeadSummaryResponse(content) {
  if (!content) return null;
  const trimmed = content.trim();
  if (!trimmed) return null;
  const jsonBlockMatch = trimmed.match(/```json([\s\S]*?)```/i);
  const textToParse = jsonBlockMatch ? jsonBlockMatch[1].trim() : trimmed;
  const buildNoteFromObject = (obj) => {
    if (!obj || typeof obj !== 'object') return null;
    const note = {};
    ['es', 'en'].forEach((lang) => {
      const value = obj[lang];
      if (typeof value === 'string' && value.trim()) {
        note[lang] = value.trim();
      }
    });
    return Object.keys(note).length ? note : null;
  };
  try {
    const parsed = JSON.parse(textToParse);
    if (typeof parsed === 'string') {
      const clean = parsed.trim();
      return clean ? { es: clean } : null;
    }
    const fromObject = buildNoteFromObject(parsed);
    if (fromObject) return fromObject;
  } catch (err) {
    // ignore parsing errors and fall back to plain text below
  }
  const fallback = textToParse.replace(/\s+/g, ' ').trim();
  return fallback ? { es: fallback } : null;
}

async function generateLeadSummaryFromConversation() {
  const transcript = buildLeadSummaryTranscript();
  if (!transcript) return null;
  const summarySystemPrompt = `Eres un asistente que redacta notas breves sobre conversaciones de clientes.
Devuelve un JSON con los campos "es" y "en".
Cada campo debe contener una frase corta (m√°ximo 30 palabras) que resuma por qu√© se obtuvo el lead y qu√© necesita el usuario.`;
  const body = {
    messages: [
      {
        role: 'user',
        content: `Transcripci√≥n del chat:\n${transcript}\n\nResume por qu√© se guard√≥ este lead.`
      }
    ],
    system: summarySystemPrompt
  };
  try {
    const response = await fetch(PROXY_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });
    if (!response.ok) {
      console.warn('No se pudo obtener el resumen del lead', response.status);
      return null;
    }
    const data = await response.json();
    const content = data?.choices?.[0]?.message?.content;
    return parseLeadSummaryResponse(content);
  } catch (err) {
    console.warn('Error al generar el resumen del lead', err);
    return null;
  }
}


/* =========================
   AUTO RESPONSES (desde Admin beta3)
========================= */
let AUTO = {}; // { id: {trigger, type, text, cards, extras} }
function tryAutoResponse(userText){
  if (!userText || !AUTO) return false;
  const t = userText.toLowerCase();
  // Encuentra la primera coincidencia simple por "includes"
  const hit = Object.values(AUTO).find(r => (r.trigger||"").toLowerCase().trim() && t.includes(r.trigger.toLowerCase().trim()));
  if (!hit) return false;

  const delayOpts = { avatarUrl: CURRENT.avatarUrl };
  const delayMs = 2000;

  if (hit.type === 'text') {
    const parts = [];
    if (hit.extras?.image) parts.push(`<img src="${hit.extras.image}" class="w-full max-w-xs rounded-lg mb-2">`);
    if (hit.extras?.title) parts.push(`<div class="font-semibold">${hit.extras.title}</div>`);
    if (hit.extras?.subtitle) parts.push(`<div class="text-sm text-gray-600">${hit.extras.subtitle}</div>`);
    if (hit.text) parts.push(`<div class="mt-1">${linkify(marked.parseInline(hit.text))}</div>`);
    if (Array.isArray(hit.extras?.buttons) && hit.extras.buttons.length){
      parts.push(`<div class="mt-2 flex flex-wrap gap-2">` +
        hit.extras.buttons.filter(b=>b?.label).map(b=>{
          const href = b.link || "#";
          return `<a href="${href}" target="_blank" class="pill-btn">${b.label}</a>`;
        }).join("") + `</div>`);
    }
    const html = parts.join("");
    delayedAssistantAction(() => addAssistantMessageHTML(html, { avatarUrl: CURRENT.avatarUrl }), delayMs, delayOpts);
    return true;
  }

  if (hit.type === 'cards') {
    const cards = (hit.cards||[]).map(c=>`
      <div class="card">
        ${c.image ? `<img src="${c.image}" alt="">` : ``}
        <div class="in">
          ${c.title? `<div class="title">${c.title}</div>`:``}
          ${c.subtitle? `<div class="sub">${c.subtitle}</div>`:``}
          ${c.link ? `<a href="${c.link}" target="_blank" class="pill-btn">${c.buttonText||'Ver'}</a>` : ``}
        </div>
      </div>
    `).join("");
    const html = `<div class="cards">${cards}</div>`;
    delayedAssistantAction(() => addAssistantMessageHTML(html, { avatarUrl: CURRENT.avatarUrl }), delayMs, delayOpts);
    return true;
  }

  if (hit.type === 'menu') {
    const label = hit.text ? `<div class="mb-2">${hit.text}</div>` : '';
    const btns = (hit.extras?.buttons||[]).map(b=>{
      if (!b?.label) return '';
      const action = b.trigger || b.link || '';
      if (/^https?:\/\//i.test(action)) {
        return `<a href="${action}" target="_blank" class="pill-btn">${b.label}</a>`;
      }
      // bot√≥n que simula un "trigger" (env√≠a el texto)
      return `<button class="pill-btn chat-option" data-trigger="${action}">${b.label}</button>`;
    }).join("");
    const html = `${label}<div class="flex flex-wrap gap-2">${btns}</div>`;
    delayedAssistantAction(() => addAssistantMessageHTML(html, { avatarUrl: CURRENT.avatarUrl }), delayMs, delayOpts);
    return true;
  }

  return false;
}

/* Delegaci√≥n para botones de men√∫ (menu->trigger) */
document.addEventListener('click', (e)=>{
  const b = e.target.closest('.chat-option');
  if (!b) return;
  const trig = (b.dataset.trigger||'').trim();
  if (!trig) return;
  // Muestra como si el usuario hubiera escrito
  addUserMessage(trig);
  handleUserMessage(trig);
});

/* =========================
   WELCOME (desde config/chatWelcome)
========================= */
function scheduleWelcome(){
  const key = `welcomeOnce_${EMPRESA}_${BOT}`;
  if (sessionStorage.getItem(key)) return;
  const ref = eref('config/chatWelcome');
  ref.once('value').then(s=>{
    const val = s.val() || {};
    if (!val.enabled) return;
    const delay = Math.max(0, parseInt(val.delay||2));
    setTimeout(()=>{
      const parts=[];
      if (val.image) parts.push(`<img src="${val.image}" class="w-full max-w-xs rounded-lg mb-2" />`);
      if (val.text) parts.push(marked.parse(val.text));
      const html = parts.join("");
      delayedAssistantAction(() => {
        addAssistantMessageHTML(html, { avatarUrl: CURRENT.avatarUrl });
        sessionStorage.setItem(key, '1');
      });
    }, delay*1000);
  });
}

/* =========================
   IA: MENSAJER√çA
========================= */
const MESSAGES = []; // {role:'system'|'user'|'assistant', content:string}
const CURRENT = { avatarUrl: "", hotelName: "", contextInfo: "", personality:"warm" };


async function askAI(userText) {
  const combinedSystem = `
  ${SYSTEM_PROMPT || ""}

  Use the following hotel information to answer the guest accurately:

  ${CURRENT.contextInfo || ""}
  `;

  const body = {
    messages: MESSAGES,
    system: combinedSystem
  };

  const res = await fetch(PROXY_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body)
  });

  if (!res.ok) throw new Error("IA request failed: " + res.status);
  const data = await res.json();
  return data?.choices?.[0]?.message?.content || "";
}

async function detectLeadIntentAI(userText) {
  try {
    const body = {
      system: "Eres un clasificador. Tu tarea es determinar si el usuario tiene intenci√≥n de entregar sus datos o de que la empresa lo contacte. Responde exclusivamente 'YES' o 'NO', sin explicaciones.",
      messages: [
        { role: "user", content: userText }
      ]
    };

    const res = await fetch(PROXY_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });

    if (!res.ok) return false;

    const data = await res.json();
    const content = (data?.choices?.[0]?.message?.content || "").toLowerCase().trim();

    return content === "yes";
  } catch (e) {
    console.warn("Intent detection failed:", e);
    return false;
  }
}

async function handleUserMessage(text){
  const safeText = typeof text === 'string' ? text : '';

  if (leadCaptureState && !leadCaptureCompleted) {

    if (leadCaptureState.step === 1) {
      leadCaptureState.name = safeText.trim();
      leadCaptureState.step = 2;
      askEmail();
      return;
    }

    if (leadCaptureState.step === 2) {
      leadCaptureState.email = safeText.trim();
      leadCaptureState.step = 3;
      askPhone();
      return;
    }

    if (leadCaptureState.step === 3) {
      leadCaptureState.phone = safeText.trim();
      leadCaptureCompleted = true;

      await saveLeadToFirebase();

      renderAssistantMessage(translate(USER_LANGUAGE, {
        es: "Gracias, ya tengo tus datos. ¬øEn qu√© puedo ayudarte ahora?",
        en: "Thanks! I have your details now. How can I help you?",
        fr: "Merci ! J'ai vos informations. Comment puis-je vous aider ?",
        de: "Danke! Ich habe deine Daten. Wie kann ich dir helfen?",
        pl: "Dziƒôkujƒô! Mam ju≈º twoje dane. W czym mogƒô pom√≥c?",
        pt: "Obrigado! J√° tenho seus dados. Como posso ajudar?"
      }));

      return;
    }
  }

  // ‚ûú ACTIVAR LEAD CAPTURE SOLO SI LA IA DETECTA INTENCI√ìN REAL
  if (
    leadCaptureEnabled &&
    !leadCaptureState &&
    !leadCaptureCompleted
  ) {
    const wantsLead = await detectLeadIntentAI(safeText);
    if (wantsLead) {
      leadPromptShown = true;
      startSequentialLeadCapture();
      return;
    }
  }

  MESSAGES.push({ role:'user', content:safeText });

  // 1) AutoResponses (si hay match, responde y no llama IA)
  if (tryAutoResponse(safeText)) return;

  // 2) IA
  const typing = showTypingIndicator();

  try{
    const reply = await askAI(safeText);
    MESSAGES.push({ role:'assistant', content: reply });
    removeTyping(typing);
    addAssistantMessage(reply, { avatarUrl: CURRENT.avatarUrl });
  }catch(err){
    console.error(err);
    removeTyping(typing);
    addAssistantMessage("Lo siento, hubo un problema al responder. ¬øPuedes intentar nuevamente?");
  }
}

/* =========================
   SEND (bot√≥n y Enter)
========================= */
async function sendNow(){
  const t = (input.value || "").trim();
  if (!t) return;
  addUserMessage(t);
  input.value = "";
  if (skipNextUserMessageForLeadCapture) {
    skipNextUserMessageForLeadCapture = false;
    return;
  }
  handleUserMessage(t);
}
sendBtn.addEventListener('click', sendNow);
input.addEventListener('keydown', e=>{ if(e.key === 'Enter'){ e.preventDefault(); sendNow(); }});

function setChatMenuVisibility(show) {
  if (!chatMenu) return;
  const shouldShow = Boolean(show);
  if (shouldShow) {
    chatMenu.classList.remove('hidden');
    chatMenuBtn?.setAttribute('aria-expanded', 'true');
  } else {
    chatMenu.classList.add('hidden');
    chatMenuBtn?.setAttribute('aria-expanded', 'false');
  }
}

function toggleChatMenu() {
  if (!chatMenu) return;
  const isHidden = chatMenu.classList.contains('hidden');
  setChatMenuVisibility(isHidden);
}

function formatConversationTimestamp(time) {
  const date = new Date(time);
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  let hours = date.getHours();
  const minutes = String(date.getMinutes()).padStart(2, '0');
  const seconds = String(date.getSeconds()).padStart(2, '0');
  const suffix = hours >= 12 ? 'PM' : 'AM';
  hours = hours % 12 || 12;
  const hh = String(hours).padStart(2, '0');
  return `${year}-${month}-${day} ${hh}:${minutes}:${seconds} ${suffix}`;
}

function buildConversationExport() {
  const lines = [];
  const hotelName = (CURRENT.hotelName || hotelNameEl?.textContent || 'Hotel assistant').trim();
  const startTime = conversationLog[0]?.time || Date.now();
  const visitorName = (typeof getChatUserName === 'function' ? getChatUserName() : 'Visitor') || 'Visitor';
  lines.push(`Conversation with ${hotelName}`);
  lines.push(`Started on ${new Date(startTime).toUTCString()}`);
  lines.push('');

  conversationLog.forEach(entry => {
    const timestamp = formatConversationTimestamp(entry.time);
    const senderLabel = entry.sender === 'bot' ? 'Chatbot' : visitorName;
    const message = (entry.text || '').replace(/\r?\n/g, '\n    ');
    lines.push(`${timestamp} | ${senderLabel}: ${message}`);
  });

  return lines.join('\n');
}

function downloadConversation() {
  const content = buildConversationExport();
  const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  const isoDate = new Date().toISOString().slice(0, 10);
  link.download = `conversation-${isoDate}.txt`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

if (chatMenuBtn) {
  chatMenuBtn.addEventListener('click', (event) => {
    event.stopPropagation();
    toggleChatMenu();
  });
}

if (downloadChatBtn) {
  downloadChatBtn.addEventListener('click', () => {
    try {
      downloadConversation();
    } finally {
      setChatMenuVisibility(false);
    }
  });
}

document.addEventListener('click', (event) => {
  if (!chatMenu || chatMenu.classList.contains('hidden')) return;
  if (chatMenu.contains(event.target)) return;
  if (chatMenuBtn && chatMenuBtn.contains(event.target)) return;
  setChatMenuVisibility(false);
});

document.addEventListener('keydown', (event) => {
  if (event.key === 'Escape') {
    setChatMenuVisibility(false);
  }
});

/* =========================
   CARGA DESDE FIREBASE (colores, logo, avatar, nombre, contexto, personality, autoResponses)
========================= */
function applyPrimaryColor(color){
  document.documentElement.style.setProperty('--chat-primary', color || '#111111');
}
function initFirebaseBindings() {
  // Colores
  eref('config/chatPrimaryColor').on('value', s => applyPrimaryColor(s.val() || '#111111'));

  // üÜï Fondo del chat
  eref('config/chatBackgroundColor').on('value', s => {
    const bg = s.val() || '#ececec';
    const chatWin = document.getElementById('chatWindow');
    if (chatWin) chatWin.style.background = bg;

    // Opcional: tambi√©n el body si el chat ocupa toda la pantalla
    document.body.style.background = bg;
  });
  
// üü£ Header Background Color
eref('config/chatHeaderColor').on('value', s => {
  const h = s.val() || '#ffffff';
  const chatHeader = document.getElementById('chatHeader');
  if (chatHeader) chatHeader.style.background = h;
});

// üÜï Header visibility toggle
const applyChatHeaderVisibility = (value) => {
  const chatHeaderEl = document.getElementById('chatHeader');
  if (!chatHeaderEl) return;
  const isVisible = value === false ? false : true;
  chatHeaderEl.style.display = isVisible ? '' : 'none';
};

eref('config/chatHeaderVisible').on('value', (s) => {
  applyChatHeaderVisibility(s.val());
});

// üü¶ Header Text Color
eref('config/chatHeaderTextColor').on('value', s => {
  const c = s.val() || '#1f2937';
  document.documentElement.style.setProperty('--chat-header-text', c);
});

// üü¢ Assistant Text Color
eref('config/chatAssistantTextColor').on('value', s => {
  const c = s.val() || '#000000';
  const msgs = document.querySelectorAll('.chat-assistant .msg');
  msgs.forEach(m => m.style.color = c);
  // Guarda el color actual para los nuevos mensajes
  document.documentElement.style.setProperty('--assistant-text', c);
});


// üü† Client Text Color
eref('config/chatClientTextColor').on('value', s => {
  const c = s.val() || '#ffffff';
  document.documentElement.style.setProperty('--chat-client-text', c);
  document.querySelectorAll('.chat-user').forEach(m => { m.style.color = c; });
});


// üü° Avatar en tiempo real
eref('config/avatarUrl').on('value', s => {
  const url = s.val() || '';
  CURRENT.avatarUrl = url;
  // Actualiza avatares visibles
  document.querySelectorAll('.avatar-icon').forEach(img => {
    if (url) img.src = url;
  });
});


  // Header hotel name
  eref('config/hotelName').on('value', s => {
    CURRENT.hotelName = s.val() || '';
    if (CURRENT.hotelName) hotelNameEl.textContent = CURRENT.hotelName;
  });

  // Logo + radio
  const logoRef = eref('config/logoUrl');
  const radiusRef = eref('config/logoRadius');
  let logoUrl = "";
  let logoRadius = 50;
  const applyLogo = () => {
    if (logoUrl) {
      chatLogo.src = logoUrl;
      chatLogo.style.borderRadius = `${logoRadius}%`;
      chatLogo.classList.remove('hidden');
    } else {
      chatLogo.classList.add('hidden');
      chatLogo.removeAttribute('src');
    }
  };
  logoRef.on('value', s => { logoUrl = s.val() || ""; applyLogo(); });
  radiusRef.on('value', s => { logoRadius = s.val() || 0; applyLogo(); });

  // Avatar
  eref('config/avatarUrl').on('value', s => {
    CURRENT.avatarUrl = s.val() || "";
  });

  const applyAvatarRadius = (value) => {
    const numeric = typeof value === 'number' ? value : parseInt(value, 10);
    const radius = Number.isFinite(numeric) ? Math.min(50, Math.max(0, numeric)) : 50;
    document.documentElement.style.setProperty('--avatar-radius', `${radius}%`);
  };

  applyAvatarRadius(50);
  eref('config/avatarRadius').on('value', s => {
    applyAvatarRadius(s.val());
  });

  // üÜï Tipograf√≠a din√°mica completa
  eref('config/fontFamily').on('value', s => {
    const f = s.val() || 'Manrope';

    // Lista de fuentes soportadas en Google Fonts
    const available = [
      "Manrope", "Inter", "Poppins", "Roboto", "Playfair Display", "Merriweather"
    ];

    // Solo intentar cargar si est√° en la lista
    if (available.includes(f)) {
      const id = `font_${f.replace(/\s+/g, '')}`;
      if (!document.getElementById(id)) {
        const link = document.createElement('link');
        link.id = id;
        link.rel = 'stylesheet';
        link.href = `https://fonts.googleapis.com/css2?family=${encodeURIComponent(f)}:wght@400;500;600;700&display=swap`;
        document.head.appendChild(link);
      }
    }

    // Aplica siempre el font-family (aunque no se haya cargado)
    document.body.style.fontFamily = `'${f}', system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
  });

  // üß† Context info + personality (con actualizaci√≥n del system prompt)
  eref('config/contextInfo').on('value', s => {
    CURRENT.contextInfo = s.val() || "";

    // üß© Si ya existe el mensaje del sistema, actual√≠zalo
    if (MESSAGES.length > 0 && MESSAGES[0].role === 'system') {
      MESSAGES[0].content = buildSystemPrompt();
    }
  });

  eref('config/personality').on('value', s => {
    CURRENT.personality = s.val() || "warm";

    // üß© Actualizar tambi√©n el prompt si cambia la personalidad
    if (MESSAGES.length > 0 && MESSAGES[0].role === 'system') {
      MESSAGES[0].content = buildSystemPrompt();
    }
  });

  // AutoResponses
  eref('config/autoResponses').on('value', s => { AUTO = s.val() || {}; });

  // Welcome
  scheduleWelcome();
}


/* =========================
   INTEGRACI√ìN CON embed.js (versi√≥n estable y limpia)
========================= */
const DEFAULT_WIDGET_ICON_PATH = 'wids/1.svg';
const DEFAULT_WIDGET_ICON_COLOR = '#ffffff';
const widgetIconSvgCache = new Map();
const widgetIconSerializer = new XMLSerializer();

const normalizeHexColor = (value = '') => {
  const raw = (value || '').toString().trim();
  if (/^#?[0-9a-fA-F]{6}$/.test(raw)) {
    return raw.startsWith('#') ? raw.toLowerCase() : `#${raw.toLowerCase()}`;
  }
  if (/^#?[0-9a-fA-F]{3}$/.test(raw)) {
    const clean = raw.replace('#', '').toLowerCase();
    const expanded = clean.split('').map((c) => c + c).join('');
    return `#${expanded}`;
  }
  return null;
};

const resolveWidgetIconUrl = (iconPath) => {
  const normalized = (iconPath || '').trim() || DEFAULT_WIDGET_ICON_PATH;
  if (normalized.startsWith('http')) return normalized;
  const cleanPath = normalized.startsWith('/') ? normalized.slice(1) : normalized;
return `https://tomos.bot/${cleanPath}`;
};

const fetchWidgetIconMarkup = async (iconPath) => {
  const url = resolveWidgetIconUrl(iconPath);
  if (widgetIconSvgCache.has(url)) return widgetIconSvgCache.get(url);
  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error('Icon fetch failed');
    const text = await res.text();
    widgetIconSvgCache.set(url, text || '');
    return text || '';
  } catch (error) {
    console.warn('No se pudo cargar el SVG del widget', error);
    return '';
  }
};

const colorizeWidgetSvg = (markup, color, size = 28) => {
  if (!markup) return null;
  const parser = new DOMParser();
  const doc = parser.parseFromString(markup, 'image/svg+xml');
  const svg = doc.querySelector('svg');
  if (!svg) return null;

  const finalColor = normalizeHexColor(color) || DEFAULT_WIDGET_ICON_COLOR;
  svg.setAttribute('fill', finalColor);
  svg.setAttribute('width', size);
  svg.setAttribute('height', size);

  svg.querySelectorAll('*').forEach((node) => {
    const tag = (node.tagName || '').toLowerCase();
    if (tag === 'svg') return;
    const fillAttr = node.getAttribute('fill');
    if (!fillAttr || fillAttr === 'currentColor') {
      node.setAttribute('fill', finalColor);
    }
    const strokeAttr = node.getAttribute('stroke');
    if (strokeAttr && strokeAttr !== 'none') {
      node.setAttribute('stroke', finalColor);
    }
  });

  return svg;
};

const getColoredWidgetSvgString = async (iconPath, color) => {
  const markup = await fetchWidgetIconMarkup(iconPath);
  const svg = colorizeWidgetSvg(markup, color);
  if (!svg) return null;
  return widgetIconSerializer.serializeToString(svg);
};

function initEmbedIntegration() {
  // üîπ estado local de visibilidad del bot√≥n (por defecto TRUE)
  let CHAT_BUTTON_VISIBLE = true;

  // üîπ Suscribirse a config/chatVisible en Firebase
  if (typeof eref === "function") {
    eref("config/chatVisible").on("value", (snap) => {
      const raw = snap.val();
      // si es false => oculto, si no existe o es true => visible
      CHAT_BUTTON_VISIBLE = raw === false ? false : true;

      // Enviar actualizaci√≥n inmediata al embed (por si ya est√° listo)
      try {
        window.parent.postMessage(
          { action: "chatButtonStatus", visible: CHAT_BUTTON_VISIBLE },
          "*"
        );
      } catch (e) {}
    });
  }

  window.addEventListener("message", (e) => {
    if (!e.data || typeof e.data !== "object") return;
    const { action } = e.data;

    if (action === "getChatButtonIcon") {
      if (typeof eref !== "function") {
        console.warn("eref no disponible a√∫n");
        return;
      }

      Promise.all([
        eref("config/widgetIcon").once("value"),
        eref("config/widgetRadius").once("value"),
        eref("config/widgetIconColor").once("value")
      ]).then(async ([iconSnap, radiusSnap, colorSnap]) => {
        const iconPath = iconSnap.val() || DEFAULT_WIDGET_ICON_PATH;
        const radius = radiusSnap.val() || 0;
        const iconColor = normalizeHexColor(colorSnap.val()) || DEFAULT_WIDGET_ICON_COLOR;

        let svg = await getColoredWidgetSvgString(iconPath, iconColor);

        if (!svg) {
          svg = `
            <svg xmlns="http://www.w3.org/2000/svg" fill="${iconColor}" viewBox="0 0 24 24">
              <path d="M7 8h10M7 12h6m-6 4h8m-5 8c-1.654 0-3-.346-3-1v-1.691c-3.771-1.466-6-4.718-6-8.309C1 5.373 5.373 1 11 1s10 4.373 10 9c0 3.591-2.229 6.843-6 8.309V21c0 .654-1.346 1-3 1z" />
            </svg>`;
        }

        window.parent.postMessage(
          { action: "chatButtonIcon", svg, radius },
          "*"
        );
      });
    }

    if (action === "getChatButtonStatus") {
      // üîπ responder usando el valor real de Firebase
      window.parent.postMessage(
        { action: "chatButtonStatus", visible: CHAT_BUTTON_VISIBLE },
        "*"
      );
    }

    if (action === "openChatWindow") {
      const w = document.getElementById("chatWindow");
      if (w) w.style.display = "flex";
    }
  });

  // Avisar que el chat est√° listo
  window.parent.postMessage({ action: "chatReady" }, "*");

  // üîπ Color del bot√≥n
  if (typeof eref === "function") {
    eref("config/chatButtonColor").on("value", (s) => {
      const color = s.val() || "#111111";
      window.parent.postMessage(
        { action: "updateChatButtonColor", color },
        "*"
      );
    });

    const sendWidgetPosition = (pos) => {
      const valid = ["left", "center", "right"];
      const normalizedInput = (pos || "").toString().trim().toLowerCase();
      const normalized = valid.includes(normalizedInput)
        ? normalizedInput
        : "right";

      window.parent.postMessage(
        { action: "updateWidgetPosition", position: normalized },
        "*"
      );
    };

    eref("config/widgetPosition").on("value", (s) => {
      sendWidgetPosition(s.val());
    });
  }
}

/* =========================
   INICIO GLOBAL (espera Firebase y luego integra embed.js)
========================= */
document.addEventListener("DOMContentLoaded", async () => {
  lucide.createIcons();
  await prepareBotPath();
  initSystemPromptListener();
  initFirebaseBindings();

  // Cerrar chat
  document.getElementById("closeChat").addEventListener("click", () => {
    try {
      if (window.parent !== window)
        window.parent.postMessage({ action: "closeChatWindow" }, "*");
    } catch (e) {}
  });

  // Iniciar integraci√≥n con embed.js despu√©s que Firebase est√© listo
  const tryInit = () => {
    if (typeof firebase !== "undefined" && typeof eref === "function") {
      initEmbedIntegration();
    } else {
      console.warn("‚è≥ Esperando Firebase para integraci√≥n...");
      setTimeout(tryInit, 600);
    }
  };
  tryInit();
});

async function saveLeadToFirebase() {
  if (!leadCaptureState) return;
  const now = Date.now();
  const lead = {
    name: leadCaptureState.name,
    email: leadCaptureState.email || "",
    phone: leadCaptureState.phone || "",
    lang: USER_LANGUAGE,
    method: 'chat',
    timestamp: now,
    capturedAt: new Date(now).toISOString(),
    time: now
  };

  try {
    const note = await generateLeadSummaryFromConversation();
    if (note) {
      lead.note = note;
    }
  } catch (err) {
    console.warn('No se pudo crear el resumen del lead', err);
  }

  try {
    const ref = db.ref(`empresas/${EMPRESA}/bots/${BOT}/leads`).push();
    await ref.set(lead);
  } catch (err) {
    console.warn('No se pudo guardar el lead', err);
  } finally {
    leadCaptureState = null;
  }
}


  </script>

</body>
</html>
